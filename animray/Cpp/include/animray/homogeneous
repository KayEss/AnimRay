/*
    Copyright 1995-2010, Kirit Saelensminde. http://www.kirit.com/AnimRay
    Distributed under the Boost Software License, Version 1.0.
    See accompanying file LICENSE_1_0.txt or copy at
        http://www.boost.org/LICENSE_1_0.txt
*/


#ifndef ANIMRAY_HOMOGENEOUS_HPP
#define ANIMRAY_HOMOGENEOUS_HPP
#pragma once


#include <animray/detail/array_based>


namespace animray {


    /// Homogenous coordinates store a location or a vector
    template < typename D, typename CR = const D & >
    class homogeneous : private detail::array_based< D, 4, CR > {
        typedef detail::array_based< D, 4, CR > superclass;
        public:
            typedef typename superclass::value_type value_type;
            typedef typename superclass::array_type array_type;
            typedef typename
                superclass::const_value_parameter_type
                const_value_parameter_type
            ;

            /// Return the 4 underlying coordinates
            const array_type &coords() const { return superclass::array; }

            /// The x coordinate
            value_type x() const { return coords()[0] / coords()[3]; }
            /// The y coordinate
            value_type y() const { return coords()[1] / coords()[3]; }
            /// The z coordinate
            value_type z() const { return coords()[2] / coords()[3]; }

            /// Constructor makes a point at the origin
            homogeneous() {
                superclass::array.c_array()[3] = 1;
            }
            /// Constructor for making a point at a given location
            homogeneous(
                const_value_parameter_type x,
                const_value_parameter_type y,
                const_value_parameter_type z
            ) {
                superclass::array.c_array()[0] = x;
                superclass::array.c_array()[1] = y;
                superclass::array.c_array()[2] = z;
                superclass::array.c_array()[3] = 1;
            }

            /// Compare for equality
            bool operator == ( const homogeneous &r ) const {
                return coords() == r.coords();
            }
            /// Compare for inequality
            bool operator != ( const homogeneous &r ) const {
                return coords() != r.coords();
            }
    };


}


namespace fostlib {


    template< typename D, typename CR >
    struct coercer< fostlib::json, animray::homogeneous< D, CR > > {
        fostlib::json coerce( const animray::homogeneous< D, CR > &h ) {
            fostlib::json r;
            for ( std::size_t i = 0; i < 4; ++i )
                fostlib::jcursor().push_back( r,
                    fostlib::coerce< fostlib::json >( h.coords()[i] )
                );
            return r;
        }
    };


}


#endif // ANIMRAY_HOMOGENEOUS_HPP
